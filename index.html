<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Round-robin-schedule by Sunlcy</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Round-robin-schedule</h1>
        <h2>This is algorithm of Round robin schedule.</h2>
        <a href="https://github.com/Sunlcy/Round-robin-schedule" class="button"><small>View project on</small> GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1>
<a id="循环赛日程表" class="anchor" href="#%E5%BE%AA%E7%8E%AF%E8%B5%9B%E6%97%A5%E7%A8%8B%E8%A1%A8" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>循环赛日程表</h1>

<h2>
<a id="目录" class="anchor" href="#%E7%9B%AE%E5%BD%95" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>目录</h2>

<ul>
<li><a href="##%20%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0">问题描述</a></li>
<li><a href="##%20%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF">算法思路</a></li>
<li><a href="##%20%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0">算法实现</a></li>
</ul>

<h2>
<a id="问题描述" class="anchor" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>问题描述</h2>

<p>设有n=2^k个运动员要进行羽毛球循环赛，现要设计一个满足以下要求的比赛日程表：</p>

<ol>
<li>每个选手必须与其他n-1个选手各赛一次；</li>
<li>每个选手一天只能赛一次；</li>
<li>循环赛一共需要进行n-1天
由于n=2^k，显然n为偶数。</li>
</ol>

<h2>
<a id="算法思路" class="anchor" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>算法思路</h2>

<p>根据分治法的思想，递归地将问题一分为二，直到只剩下两个人比赛，最后在将这些问题合并起来，这样问题就变得十分简单。日程表的制定过程中存在一定的规律，即第i行第j列表示第i个选手在第j天所遇到的选手。这样算法就很容易实现了。</p>

<p><img src="https://github.com/Sunlcy/Round-robin-schedule/blob/master/pictures/first-time.jpg" alt="first-time"></p>

<p>2^1个选手的比赛日程表</p>

<p>当问题规模为2^1时，此时问题最为简单，只需要将每个选手复制到对角线位置即可。</p>

<p><img src="https://github.com/Sunlcy/Round-robin-schedule/blob/master/pictures/second-time.jpg" alt="second-time"></p>

<p>2^2个选手的比赛日程表</p>

<p>当问题规模为2^2时，将问题划分为2个规模为2^1的子问题，先解决子问题，然后在将问题规模为2^1的子问题看作一个整体，并复制到对角线位置，这时即可得到总问题的解。</p>

<p><img src="https://github.com/Sunlcy/Round-robin-schedule/blob/master/pictures/third-time.jpg" alt="third-time"></p>

<p>2^3个选手的比赛日程表</p>

<p>与上面类似，先将问题划分为4个问题规模为2^1的子问题，分别解决后，再将这些子问题看作一个整体分别复制到对角线处，即可得到两个问题规模为2^2的子问题，最后再将规模变大了的子问题分别复制到对角线处，即可得到总问题的解。</p>

<p>……</p>

<h2>
<a id="算法实现" class="anchor" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>算法实现</h2>

<p>这里我只对代码的关键部分做简要的解释，即下面部分：</p>

<div class="highlight highlight-source-c++"><pre>#<span class="pl-k">define</span> <span class="pl-en">N</span> <span class="pl-c1">3</span>
...
<span class="pl-k">int</span> sche = pow(<span class="pl-c1">2.0</span>, N);      <span class="pl-c">// divide the problem to pow(2, k) subproblems</span>
...

<span class="pl-k">for</span> (<span class="pl-k">int</span> j = <span class="pl-c1">0</span>; j &lt; N; j++)
    {
        <span class="pl-c">// gets the size of the problem,</span>
        <span class="pl-c">// every loop the problem will triple</span>
        bw = <span class="pl-c1">pow</span>(<span class="pl-c1">2.0</span>, j);
        <span class="pl-k">for</span> (<span class="pl-k">int</span> r = <span class="pl-c1">0</span>; r &lt; bw; r++)
        {
            <span class="pl-k">for</span> (<span class="pl-k">int</span> c = <span class="pl-c1">0</span>; c &lt; sche; c++)
            {
                <span class="pl-c">// uses round to get the index of problem block</span>
                bid = (c + bw) / bw;
                c_offset = <span class="pl-c1">pow</span>(-<span class="pl-c1">1.0</span>, bid + <span class="pl-c1">1</span>) * bw;
                r_offset = bw;
                arr[r + r_offset][c + c_offset] = arr[r][c];
            }
        }
    }</pre></div>

<p>代码中使用了三层循环，最外层的循环控制问题的规模，即当j=0时，问题规模最小，即前面介绍的规模为2^1的问题；当j=1时，问题规模为2^2；当j=2时，问题规模为2^3……以此类推。这部分可以最能体现分治法的特点，将大问题划分为小问题。</p>

<p>第二层与第三层分别控制元素的行和列，这两层循环主要负责解决不同规模的问题，简单地说就是分别将不同规模的问题块复制到对角线的位置。</p>

<p>为了完成这个看似简单的过程，我们首先需要找一下规律(由于2^k必为偶数，所以n为奇数)：</p>

<ul>
<li>子问题规模为2^1(j=0)时，</li>
</ul>

<p>a[0][0]--&gt;a[1][1]</p>

<p>a[0][1]--&gt;a[1][0]</p>

<p>a[0][2]--&gt;a[1][3]</p>

<p>a[0][3]--&gt;a[1][2]</p>

<p>...</p>

<p>a[0][n-1]--&gt;a[0+2^0][(n-1)+2^0]</p>

<p>a[0][n]--&gt;a[0+2^0][n-2^0]</p>

<p>也就是说当元素的ID(ID=列号+1)为奇数时，移动到右下角(横纵坐标分别加2^0)；当列ID为偶数时，移动到左下角(横坐标减2^0，纵坐标加2^0)。</p>

<ul>
<li>子问题规模为2^2(j=1)时，</li>
</ul>

<p>a[0][0]--&gt;a[2][2]</p>

<p>a[0][1]--&gt;a[2][3]</p>

<p>a[0][2]--&gt;a[2][0]</p>

<p>a[0][3]--&gt;a[2][1]</p>

<p>...</p>

<p>a[0][n-3]--&gt;a[0][(n-3)+2^1]</p>

<p>a[0][n-2]--&gt;a[0][(n-2)+2^1]</p>

<p>a[0][n-1]--&gt;a[0+2^1][(n-1)-2^1]</p>

<p>a[0][n]--&gt;a[0+2^1][n-2^1]</p>

<p>现在规律就没有那么明显了，但是如果我们按照整块来找规律的话，那么规律就相对容易找一些。你可以这样划分块：即按照2x2的块来划分，每个块都对应一个ID，同样当ID为奇数时，移动到右下角(横纵坐标分别加2^1)；当ID为偶数时，移动到左下角(横坐标减2^1，纵坐标加2^1)。</p>

<p><strong>NOTE:</strong>其实问题规模为2^1时，块的大小为1x1。</p>

<ul>
<li>当子问题规模为2^3(j=2)时，</li>
</ul>

<p>a[0][0]--&gt;a[4][4]</p>

<p>...</p>

<p>a[0][2]--&gt;a[4][6]</p>

<p>...</p>

<p>a[0][4]--&gt;a[4][0]</p>

<p>...</p>

<p>a[0][7]--&gt;a[4][3]</p>

<p>很显然，这里块的大小为4x4，移动的方法我这里也就不在赘述了。</p>

<p>综上所述，块的大小分别是2^0x2^0，2^1x2^1，2^2x2^x,...,2^nx2^n，每次都按照块来进行对角线复制，这时规律就显而易见了，所以r(行ID)的最大值就是块的宽度。但是还有一个比较棘手的问题——如何将数组中的每个元素与块的ID一一映射呢？我经过一番思考终于找到了规律：</p>

<p><strong>BLOCK_ID = (COL_ID + BLOCK_WIDTH)/BLOCK_WIDTH</strong></p>

<p>原代码中是这样写的:</p>

<pre><code>  bid = (c + bw) / bw;
</code></pre>

<p>其实上面这个式子的灵感来源于我最近在学的CUDA编程中一个经典例子<g-emoji alias="smile" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f604.png" ios-version="6.0">😄</g-emoji>，在那里我学到了圆整(rounding)这个概念(实际上在学习python时，我也遇到过这个概念，只是当时并没有在意)，圆整的方式有很多，常见的就有向上圆整(round up)和向下圆整(round down)，如果你对圆整感兴趣，可以参考相关词条<a href="https://en.wikipedia.org/wiki/Rounding">rounding</a>。在我的这个式子中就用到了向上取整的方式，很容易理解，这里就不在赘述了。</p>

<p>到这里，所有的问题都解决了。</p>

<p><strong>NOTE:</strong>细心的朋友可能会注意到，源码中是按行复制的。这与图中按列复制并不一致，但原理是一样的。</p>
        </section>

        <aside id="sidebar">
          <a href="https://github.com/Sunlcy/Round-robin-schedule/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/Sunlcy/Round-robin-schedule/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/Sunlcy/Round-robin-schedule"></a> is maintained by <a href="https://github.com/Sunlcy">Sunlcy</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>
